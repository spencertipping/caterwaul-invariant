// Invariance across state transitions | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module reduces state management to an invariant definition. You then provide it with state transitions and it propagates those changes as necessary to preserve the invariants that you've
// specified. You can add and remove nodes from the graph at any point, and you can write your own node types that govern how propagation takes place. This library provides several built-in node
// types that handle things like caching and retrying.

// Graphs are made of nodes connected with edges. Nodes determine state-preservation and change propagation behavior. So, for example, here's how you would design a trivial RPC-based web app
// given this model:

// | view <-> RPC  ...  RPC <-> database

// When the user made a change in the view, the change would be propagated to the RPC node. That RPC, upon receiving the change, would initiate the AJAX call to propagate the change to the
// server, which would propagate it to the database. The database would confirm that the change was made successfully, that confirmation would end up traveling all the way back to the client, and
// the future state would be displayed in the UI. Any failures would be handled transparently by whichever node failed to propagate its state.

// Fanout cases.
// The example above is simplistic because each node has at most two edges; the propagation direction is obvious. Things become more interesting when you have things like client-side components
// that are linked. In that case you'd have a graph like this:

// | view 1
//         \
//          RPC  ...  RPC <-> database
//         /
//   view 2

// Here, any changes made to view 1 are immediately propagated to view 2 and vice versa. Further, any changes from the server will automatically be propagated to both views. This means that
// multiple clients can edit the data at once, and changes will be propagated back accordingly. The update will be tentative until all nodes have confirmed. This means that while view 2 will
// update instantaneously, view 1 will observe a pending update until the RPC confirms.

// Componentwise data.
// Let's suppose you've got an app that does something like keep track of the population of every city in the world. When someone updates a city, you don't want to propagate that change to every
// single client. You only need to propagate it to the clients that have some reason to listen for changes to that city. One solution is to cop out entirely and use a pull-only API, but this
// doesn't help apps that use bidirectional AJAX.

// This library provides a filter node that solves exactly this problem. For the city app, you'd put it on the server like this:

// | view <-> RPC  ...  filter_1(RPC) -               <- this is one client
//                                     \
//   view <-> RPC  ...  filter_2(RPC) - database      <- this is another
//                                     /
//   view <-> RPC  ...  filter_3(RPC) -               <- and a third

// Each filter prevents the RPC channels from being saturated with state transitions that don't impact the clients in question. Now, a reasonable concern at this point is how the filters are
// synchronized with the client states. The solution is to use another node, of course:

// |      RPC      ...  RPC
//       /                 \
//   view <-> RPC  ...  filter(RPC) <-> database

// The secondary RPC node maintains the filter state; as the view changes, it updates this RPC and the filter is updated remotely.
// Generated by SDoc 
